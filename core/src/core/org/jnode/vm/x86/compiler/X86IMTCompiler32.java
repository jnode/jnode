/*
 * $Id$
 *
 * JNode.org
 * Copyright (C) 2005 JNode.org
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License 
 * along with this library; if not, write to the Free Software Foundation, 
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
 */
 
package org.jnode.vm.x86.compiler;

import org.jnode.assembler.ObjectResolver;
import org.jnode.assembler.x86.X86Assembler;
import org.jnode.assembler.x86.X86Register;
import org.jnode.assembler.x86.X86Utils;
import org.jnode.util.LittleEndian;
import org.jnode.vm.classmgr.ObjectLayout;
import org.jnode.vm.classmgr.TIBLayout;
import org.jnode.vm.classmgr.VmArray;
import org.jnode.vm.classmgr.VmClassLoader;
import org.jnode.vm.classmgr.VmMethod;
import org.jnode.vm.compiler.CompiledIMT;
import org.jnode.vm.compiler.IMTCompiler;

/**
 * @author Ewout Prangsma (epr@users.sourceforge.net)
 */
public final class X86IMTCompiler32 extends IMTCompiler implements X86CompilerConstants {

	private final int codeOfs = 24;

	private final int selectorOfs = 72;

	/** Register that holds the selector */
	public static final X86Register SELECTOR_REG = X86Register.EDX;

	/** Size in bytes of an entry in the IMT jump table generated by this method. */
	private static final int IMT_ENTRY_SIZE = 9;
	
	/**
	 * Initialize this instance.
	 */
	public X86IMTCompiler32() {
	}

	/**
	 * Generate the actual invocation code of an interface method.
	 * Inputs:
	 *   EDI statics table (EDI is preserved)
	 *   EAX object to invoke method on (EAX is destroyed)
	 * @param os
	 */
	public static void emitInvokeInterface(X86Assembler os, VmMethod method) {
		final int selector = method.getSelector();
		final int index = selector % ObjectLayout.IMT_LENGTH;
		final int offset = (VmArray.DATA_OFFSET * 4) + (index * IMT_ENTRY_SIZE);
		
		// For debugging only
		//os.writeMOV_Const(Register.ESI, offset);
		
		// Get tib into EAX
		os.writeMOV(INTSIZE, X86Register.EAX, X86Register.EAX, ObjectLayout.TIB_SLOT * 4);
		// Get selector into EDX
		os.writeMOV_Const(X86Register.EDX, selector);
		// Get compiled IMT into EAX
		os.writeMOV(INTSIZE, X86Register.EAX, X86Register.EAX, (TIBLayout.COMPILED_IMT_INDEX + VmArray.DATA_OFFSET) * 4);
		// Call to offset within compiled IMT
		os.writeLEA(X86Register.EAX, X86Register.EAX, offset);
		os.writeCALL(X86Register.EAX);
	}
	
	/**
	 * Initialize this compiler
	 * 
	 * @param loader
	 */
	public void initialize(VmClassLoader loader) {
		final X86CompilerContext context = new X86CompilerContext(loader, null,
				0);
		final int actCodeOfs = context.getVmMethodNativeCodeField().getOffset();
		final int actSelectorOfs = context.getVmMethodSelectorField()
				.getOffset();

		if (codeOfs != actCodeOfs) {
			throw new InternalError("Set codeOfs to " + actCodeOfs);
		}
		if (selectorOfs != actSelectorOfs) {
			throw new InternalError("Set selectorOfs to " + actSelectorOfs);
		}

		if (!X86Utils.isByte(codeOfs)) {
			throw new InternalError(
					"Offset to NativeCode field is out of imm8 range");
		}
		if (!X86Utils.isByte(selectorOfs)) {
			throw new InternalError(
					"Offset to Selector field is out of imm8 range");
		}
	}

	/**
	 * @see org.jnode.vm.compiler.IMTCompiler#compile(ObjectResolver, Object[], boolean[])
	 */
	public CompiledIMT compile(ObjectResolver resolver__, Object[] imt,
			boolean[] imtCollisions) {
		final int imtLength = imt.length;

		if (codeOfs < 0) {
			throw new InternalError("Not initialized yet");
		}

		// Calculate size of code array
		int size = imtLength * IMT_ENTRY_SIZE;
		for (int i = 0; i < imtLength; i++) {
			if (imtCollisions[i]) {
				final Object[] arr = (Object[]) imt[i];
				size += arr.length * 15;
			}
		}

		final byte[] code = new byte[size];
		// Create the jump table
		int extraIndex = imtLength * IMT_ENTRY_SIZE;
		for (int i = 0; i < imtLength; i++) {
            final int ofsStart = i * IMT_ENTRY_SIZE;
            int ofs = ofsStart;

			if (imtCollisions[i]) {
				// Complex route
				final Object[] arr = (Object[]) imt[i];
				final int arrLength = arr.length;
				final int jmpEaxCodeOfs;

				// JMP extraIndex
				code[ofs++] = (byte) 0xE9;
				LittleEndian.setInt32(code, ofs, (extraIndex - ofs) - 4);
				ofs += 4;

				// JMP [eax+codeOfs]
				jmpEaxCodeOfs = ofs;
				// JMP [EAX+codeOfs]
				ofs = genJmpEaxCodeOfs(code, ofs);

				// Create extra field
				for (int k = 0; k < arrLength; k++) {
					// MOV EAX,[edi+method_statics_index]
					final VmMethod method = (VmMethod)arr[k];
					extraIndex = genMovMethod2Eax(code, extraIndex, method.getStaticsIndex());

					if (k + 1 == arrLength) {
						// Last entry, jump directly
						// JMP [eax+codeOfs]
						extraIndex = genJmpEaxCodeOfs(code, extraIndex);
					} else {
						// Non-last entry, compare and jump of select match

						// CMP [eax+selectorOfs],selectorReg
						code[extraIndex++] = (byte) 0x39;
						code[extraIndex++] = (byte) 0x50;
						code[extraIndex++] = (byte) selectorOfs;

						// JE jmpEaxCodeOfs
						code[extraIndex++] = (byte) 0x0F;
						code[extraIndex++] = (byte) 0x84;
						LittleEndian.setInt32(code, extraIndex,
								(jmpEaxCodeOfs - extraIndex) - 4);
						extraIndex += 4;
					}
				}
			} else if (imt[i] != null) {
				// Simple route

				// MOV EAX,Method
				final VmMethod method = (VmMethod)imt[i];
				ofs = genMovMethod2Eax(code, ofs, method.getStaticsIndex());

				// JMP [EAX+codeOfs]
				ofs = genJmpEaxCodeOfs(code, ofs);
			} else {
				// Empty IMT slot
				// INT ABSTRACT_METHOD
				code[ofs++] = (byte)0xCD;
				code[ofs++] = (byte)X86CompilerConstants.ABSTRACT_METHOD_INTNO;
				// Fill with NOP's
				code[ofs++] = (byte)0x90;
				code[ofs++] = (byte)0x90;
				code[ofs++] = (byte)0x90;
				code[ofs++] = (byte)0x90;
				code[ofs++] = (byte)0x90;
				code[ofs++] = (byte)0x90;
				code[ofs++] = (byte)0x90;
			}
            
            if (ofs > ofsStart + IMT_ENTRY_SIZE) {
                throw new InternalError("Adjust IMT_ENTRY_SIZE to " + (ofs - ofsStart));
            }
		}

		return new X86CompiledIMT(code);
	}

	/**
	 * Generate: MOV EAX,[EDI+staticsOffset]
	 * 
	 * @param code
	 * @param ofs
	 * @param objPtr
	 * @return the new offset
	 */
	private final int genMovMethod2Eax(byte[] code, int ofs, int staticsIndex) {
		final int offset = (staticsIndex + VmArray.DATA_OFFSET) * 4;		
		code[ofs++] = (byte) 0x8B;
		code[ofs++] = (byte) 0x87;
		LittleEndian.setInt32(code, ofs, offset);
		return ofs + 4;
	}

	/**
	 * Generate: JMP [EAX+codeOfs]
	 * 
	 * @param code
	 * @param ofs
	 * @return the new offset
	 */
	private final int genJmpEaxCodeOfs(byte[] code, int ofs) {
		// JMP [EAX+codeOfs]
		code[ofs++] = (byte) 0xFF;
		code[ofs++] = (byte) 0x60;
		code[ofs++] = (byte) codeOfs;
		return ofs;
	}
}
